<section>
<p>Runtime is an important aspect of actuarial cash flow models. With the tight reporting deadlines, actuaries are keen to have results as fast as possible.
  In this post, we will discuss how to measure and improve the runtime of actuarial cash flow models.</p>

<hr class="divider">

<p>List of content:</p>
<ol>
  <li><a href="#speed">How to improve speed of model?</a></li>
  <ul>
    <li><a href="#speed_multiprocessing">Multiprocessing</a></li>
    <li><a href="#speed_indexing">Indexing assumptions</a></li>
    <li><a href="#speed_max_period">Maximal calculation period</a></li>
    <li><a href="#speed_fit">Fit formulas</a></li>
  </ul>
  <li><a href="#runtime">How to measure runtime?</a></li>
</ol>

<hr class="divider">
</section>


<section>
<h2 id="speed">How to improve speed of model?</h2>

<p>Firstly, we will discuss how to improve the speed of the actuarial cash flow models.
  In particular, we will discuss the following aspects:</p>
<ul>
  <li>multiprocessing,</li>
  <li>indexing assumptions,</li>
  <li>maximal calculation period,</li>
  <li>fit formulas.</li>
</ul>


<h3 id="speed_multiprocessing">Multiprocessing</h3>

<p>The model is evaluated for each model point one after another.
  It's also possible to calculate multiple model points at the same time and then to combine results.
  Modern computers have multiple cores that allow to perform calculations in parallel.</p>

  <div class="vertical-center">
  <img src="/static/img/28/multiprocessing.png">
  </div>

<p>To turn on parallel calculations, set the <span class="inline-code">MULTIPROCESSING</span> setting to <span class="inline-code">True</span>.</p>

<span class="source">settings.py</span>
<div class="code">
<pre><code>settings = {
    ...
    "MULTIPROCESSING": True,
    ...
}
</code></pre>
</div>

<p>The model will split all model points into more or less equal parts, calculate them in parallel on multiple cores and then merge together into a single output.
  Thanks to that, the runtime will be decreased. The more cores, the faster calculation.
</p>

<p>It is recommended to use <span class="inline-code">MULTIPROCESSING</span> when the model is stable.
  If you are developing the model, it's better to use single processing.
  The log messages might be vague, while multiprocessing.</p>


<h3 id="speed_indexing">Indexing assumptions</h3>

<p>Reading data from external files impacts the runtime materially.
  To speed up reading data from assumptions files, we can use <b>indexing</b>.</p>

<p>Let's take a mortality table as an example. The first column is <span class="inline-code">AGE</span>
  and then there are two columns (<span class="inline-code">MALE</span> and <span class="inline-code">FEMALE</span>) with actual mortality rates.</p>

<span class="source">mortality.csv</span>
<div class="code">
<pre><code>AGE     MALE   FEMALE
  0  0.00389  0.00315
  1  0.00028  0.00019
  2  0.00019  0.00014
  3  0.00015  0.00011
  4  0.00012  0.00009
...      ...      ...
 96  0.28581  0.25969
 97  0.30122  0.27829
 98  0.31662  0.29696
 99  0.33192  0.31554
100  0.34704  0.33387
</code></pre>
</div>

<p>In this table, we can set the <span class="inline-code">AGE</span> column as an index because we always read a mortality rate for the given age.</p>


<p>Let's do that:</p>

<span class="source">assumption.py</span>
<div class="code">
<pre><code>assumption["mortality"] = pd.read_csv("./input/mortality.csv", index_col="AGE")
</code></pre>
</div>

<p>Once we've set the index column, we can read data using the <span class="inline-code">loc</span> method:</p>

<span class="source">model.py</span>
<div class="code">
<pre><code>@variable()
def mortality_rate(t):
    sex = main.get("SEX")
    if age(t) == age(t-1):
        return mortality_rate(t-1)
    elif age(t) <= 100:
        yearly_rate = assumption["mortality"].loc[age(t)][sex]
        monthly_rate = (1 - (1 - yearly_rate)**(1/12))
        return monthly_rate
    else:
        return 1
</code></pre>
</div>

<p>Let's take a closer look:</p>

<div class="code">
<pre><code>assumption["mortality"].loc[age(t)][sex]
</code></pre>
</div>

<p>We use <span class="inline-code"code>loc</span> to locate the given age in the index column
  and then choose the column indicated by sex (<span class="inline-code">MALE</span>/<span class="inline-code">FEMALE</span>).</p>

<p>Having an index in place improves the speed of reading data.</p>

<h3 id="speed_max_period">Maximal calculation period</h3>

<p>By default, the maximal calculation is set to 720 (60 years). If such a long calculation horizon is not needed, then decrease it.
  You will get rid of unnecessary calculations that do not impact the result.</p>

<span class="source">settings.py</span>
<div class="code">
<pre><code>settings = {
    ...
    "T_MAX_CALCULATION": 480,
    ...
}
</code></pre>
</div>


<h3 id="speed_fit">Fit formulas</h3>

<p>While defining model variables, we should avoid unnecessary calculations.
  For example, we know that reading assumptions from tables takes time.</p>

<p>We could consider a different approach to the following formula.</p>

<div class="code">
<pre><code>@variable()
def mortality_rate(t):
    sex = main.get("SEX")
    if age(t) <= 100:
        yearly_rate = float(assumption["mortality"].loc[age(t)][sex])
        monthly_rate = (1 - (1 - yearly_rate)**(1/12))
        return monthly_rate
    else:
        return 1
</code></pre>
</div>

<p>We know that the age changes only every 12 months. There is no need to read data from the assumption table for the remaining 11 months.</p>

<p>We can add an if-statement that checks whether the age has changed:</p>

<div class="code">
<pre><code>if age(t) == age(t-1):
    return mortality_rate(t-1)
</code></pre>
</div>

<p>Thanks to that we save some computational time. Let's see the full formula.</p>

<div class="code">
<pre><code>@variable()
def mortality_rate(t):
    sex = main.get("SEX")
    if t > 0 and age(t) == age(t-1):
        return mortality_rate(t-1)
    elif age(t) <= 100:
        yearly_rate = float(assumption["mortality"].loc[age(t)][sex])
        monthly_rate = (1 - (1 - yearly_rate)**(1/12))
        return monthly_rate
    else:
        return 1
</code></pre>
</div>

</section>



<section>
<h2 id="runtime">How to measure runtime?</h2>

<p>The cashflower package produces a diagnostic file by default.</p>

<span class="source">settings.py</span>
<div class="code">
<pre><code>settings = {
    ...
    "SAVE_DIAGNOSTIC": True,
    ...
}
</code></pre>
</div>

<p>The model creates the <span class="inline-code">&lt;timestamp&gt;_diagnostic.csv</span>
  file in the <span class="inline-code">output</span> folder.</p>

<div class="code">
<pre><code>  .
  └── output/
      └── &lt;timestamp&gt;_diagnostic.csv
</code></pre>
</div>

<p>The diagnostic file contains different diagnostic information.
  One of these information is the runtime per variable.</p>

<span class="source">&lt;timestamp&gt;_diagnostic.csv</span>
<div class="code">
<pre><code>variable,runtime
survival_rate,10.84
expected_benefit,16.44
net_single_premium,12.99
</code></pre>
</div>

<p>We can analyze this file and check which variables take most of the runtime.</p>
</section>

<br>

<p>Thanks for reading the post! If you have any questions or your own ideas of how to improve runtime of models, please share!
You can use the comment section below or <a href="https://github.com/acturtle/cashflower/discussions" target="_blank">the github repository</a>.
</p>
