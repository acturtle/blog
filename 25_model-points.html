<section>
<p>Model points are one of the inputs of the actuarial cash flow models.
  In this post, we will discuss what model points are and how to set them up.</p>

<hr class="divider">

<p>List of content:</p>
<ol>
  <li><a href="#what_are">What are model points?</a></li>
  <li><a href="#cheatsheet">Cheatsheet</a></li>
  <ul>
    <li><a href="#cheatsheet_define">Define model point set</a></li>
    <li><a href="#cheatsheet_link">Link variable with model point set</a></li>
    <li><a href="#cheatsheet_id_column">Change the identifier name</a></li>
    <li><a href="#cheatsheet_read_other_set">Read data from other model point set</a></li>
  </ul>
  <li><a href="#example">Modelling example: whole life with riders</a></li>
  <ul>
    <li><a href="#example_data_format">Data format</a></li>
    <li><a href="#example_preparation">Preparation</a></li>
    <li><a href="#example_model">Model</a></li>
    <li><a href="#example_results">Results</a></li>
  </ul>
</ol>

<hr class="divider">
</section>

<section>
<h2 id="what_are">What are model points?</h2>

<p>In short, a model point is a record or multiple records used for the actuarial cash flow models.</p>

<p>Actuarial cash flow models have two main types of inputs: assumptions and model points.
  If you model life insurance, assumptions include mortality rates, lapse rates and interest rates.
  Model points are policy data which contain information on policyholders (age, sum insured, fund value etc.).
  If you model assets, model points can include characteristics of financial assets such as bonds.
</p>

<p>In the past, it was common to group multiple objects (e.g. multiple policyholders) with similar characteristics into one model point.
  Thanks to that, the model could run faster. Nowadays, it's not so common, because grouping requires additional work and computers just got faster.
</p>

<p>In <a href="https://pypi.org/project/cashflower/" target="_blank">cashflower</a>, the following naming convention is used:</p>
<ul>
  <li><b>model point set</b> - a group of model points; it can have a form of a file or a database query result,</li>
  <li><b>model point</b> - one or multiple records that contain data on the given object (e.g. policyholder or financial asset),</li>
  <li><b>record</b> - a single row of data.</li>
</ul>

<p>Each actuarial cash flow model must have a model point set named <span class="inline-code">main</span>.
  The <span class="inline-code">main</span> model point set must have one record per model point.
  The model point set contains a column that contains an identification of an object (<span class="inline-code">id</span>).</p>

<div class="vertical-center">
  <img src="/static/img/25/single_model_point_set.png">
</div>

<p>In this example, there are 5 policyholders.
  The policyholder with the identifier <span class="inline-code">2</span> is a 64-year old male who pays €270 premium.</p>

<p>A cash flow model can have multiple model point sets.
  Model point sets other than <span class="inline-code">main</span> can have multiple records per model point.</p>

<div class="vertical-center">
  <img src="/static/img/25/multiple_model_point_sets.png">
</div>

<p>The above model has 3 model point sets: <span class="inline-code">main</span>, <span class="inline-code">coverage</span> and <span class="inline-code">fund</span>.
  The model point for the identifier <span class="inline-code">2</span> has 5 records
  (1 in <span class="inline-code">main</span>, 2 in <span class="inline-code">coverage</span> and 2 in <span class="inline-code">fund</span>).</p>

<hr class="divider">
</section>


<section>
<h2 id="cheatsheet">Cheatsheet</h2>

<p>Cheatsheet for using model points with <a href="https://pypi.org/project/cashflower/" target="_blank">cashflower</a>.</p>


<h3 id="cheatsheet_define">Define model point set</h3>

<p>Model point sets are defined in the <span class="inline-code">input.py</span> script.
  There <b>must</b> be a model point set assigned to the <span class="inline-code">main</span> variable.
  In the <span class="inline-code">main</span> model point set, each record must be a unique model point.
  The <span class="inline-code">id</span> column contains identifier for model point objects.</p>

<span class="source">input.py</span>
<div class="code">
<pre><code>from cashflower import ModelPointSet

main = ModelPointSet(data=pd.DataFrame({
    "id": [1, 2, 3],
    "age": [45, 52, 63]
    "sex": ["F", "M", "F"],
    "premium": [100, 125, 110],
}))


fund = ModelPointSet(data=pd.DataFrame({
    "id": [1, 1, 2, 2, 3],
    "fund_code": ["AA", "BX", "TR", "XA", "EF"]
    "fund_value": [15000, 8000, 12000, 3000, 4000],
}))
</code></pre>
</div>


<h3 id="cheatsheet_link">Link variable with model point set</h3>

<p>If you define a model variable and don't link a model point set specifically, it will be linked to the <span class="inline-code">main</span> model point set by default.</p>

<span class="source">model.py</span>
<div class="code">
<pre><code>from cashflower import ModelVariable
from my_model.input import main, fund

pv_premium = ModelVariable()
</code></pre>
</div>

<p>...is equivalent to...</p>

<span class="source">model.py</span>
<div class="code">
<pre><code>from cashflower import ModelVariable
from my_model.input import main, fund

pv_premium = ModelVariable(model_point_set=main)
</code></pre>
</div>

<p>If you have multiple model point sets, you need to link the model variable with the model point set other than <span class="inline-code">main</span> specifically.</p>

<span class="source">model.py</span>
<div class="code">
<pre><code>from cashflower import ModelVariable
from my_model.input import main, fund

pv_premium = ModelVariable()
fund_value = ModelVariable(model_point_set=fund)
</code></pre>
</div>


<h3 id="cheatsheet_id_column">Change the identifier name</h3>

<p>Each model point set must have a column which identifies model points. By default, this column is named <span class="inline-code">id</span>.</p>

<span class="source">settings.py</span>
<div class="code">
<pre><code>settings = {
    ...
    "ID_COLUMN": "id",
    ...
}

</code></pre>
</div>

<br>

<span class="source">input.py</span>
<div class="code">
<pre><code>from cashflower import ModelPointSet

main = ModelPointSet(data=pd.DataFrame({
    "id": [1, 2, 3],
    ...
}))


fund = ModelPointSet(data=pd.DataFrame({
    "id": [1, 1, 2, 2, 3],
    ...
}))
</code></pre>
</div>

<p>You can change the name of the identifier column using the <span class="inline-code">ID_COLUMN</span> setting.</p>

<span class="source">settings.py</span>
<div class="code">
<pre><code>settings = {
    ...
    "ID_COLUMN": "POLICY_ID",
    ...
}
</code></pre>
</div>

<br>

<span class="source">input.py</span>
<div class="code">
<pre><code>from cashflower import ModelPointSet

main = ModelPointSet(data=pd.DataFrame({
    "POLICY_ID": [1, 2, 3],
    ...
}))


fund = ModelPointSet(data=pd.DataFrame({
    "POLICY_ID": [1, 1, 2, 2, 3],
    ...
}))
</code></pre>
</div>

<p>Remember that Python is case-sensitive!</p>

<h3 id="cheatsheet_read_other_set">Read data from other model point set</h3>

<p>You might need to access the value of the model point's records from another set. You can do it directly inside the formula.</p>

<span class="source">model.py</span>
<div class="code">
<pre><code>expected_coverage_benefit(t=10, r=1)
</code></pre>
</div>

<p>This code will read the value for the <span class="inline-code">expected_coverage_benefit</span> variable for the second record.
  (Remember that counting starts with <span class="inline-code">0</span> in Python!)</p>

<p>If you want to sum the value from all records and the number of records can vary, you can use the <span class="inline-code">model_point_size</span> attribute of the model point set.
  It will return the number of records for the currently evaluated model point in the given model point set.
</p>

<span class="source">model.py</span>
<div class="code">
<pre><code>@assign(expected_benefit)
def _expected_benefit(t):
    result = 0
    for r in range(coverage.model_point_size):
        result += expected_coverage_benefit(t, r)
    return result
</code></pre>
</div>

<br>
<hr class="divider">
</section>


<section>
<h2 id="example">Modelling example: whole life with riders</h2>

<h3 id="example_data_format">Data format</h3>

<p>In this example, we will cover a product where a policyholder can have multiple coverages.
  For example, the policyholder can be insured against death and illness within the same policy.</p>

<p>The easiest approach would be to have additional columns in the main model point set that would contain information on the additional coverages.
  However, with multiple coverages, the model point file might grow out of proportion. Also, some policyholders can have one coverage and others multiple.
  If the policyholder is insured only against death then the remaining columns would remain empty.</p>

<div class="code">
<pre><code>print(main.data)

  ID  AGE    SEX  PREMIUM SUM_ASSURED_DEATH SUM_ASSURED_ILLNESS
   1   32   MALE    140.0        100 000.00           30 000.00
   2   48 FEMALE    150.0        120 000.00                 NaN
</code></pre>
</div>

<p>A more efficient solution is to store coverage data in the long format in a separate file.
If the policyholder has 2 coverages, then there will be 1 record in the main model point set and 2 in the additional one.
If the policyholder has only 1 coverage, there will be 1 record in each of the files.</p>

<div class="code">
<pre><code>print(main.data)

ID  AGE    SEX  PREMIUM
 1   32   MALE    140.0
 2   48 FEMALE    150.0
</code></pre>
</div>

<br><br>

<div class="code">
<pre><code>print(coverage.data)

ID  SUM_ASSURED     TYPE
 1   100 000.00    DEATH
 1    30 000.00  ILLNESS
 2   120 000.00    DEATH
</code></pre>
</div>

<p>In the following example, we will build an actuarial cash flow model for the whole life insurance with an illness rider.</p>


<h3 id="example_preparation">Preparation</h3>

<p>Install the <a href="https://cashflower.acturtle.com/">cashflower</a> package, if you don't have it yet.</p>

<span class="source">terminal</span>
<div class="code">
<pre><code>pip install cashflower</code></pre>
</div>

<p>Create a new model named <i>mult_cov</i>.</p>

<span class="source">python console</span>
<div class="code">
<pre><code>from cashflower import create_model

create_model("mult_cov")</code></pre>
</div>

<p>The new folder <span class="inline-code">mult_cov</span> has been created with the initial files structure.</p>

<p>Let's prepare model point sets and assumptions for the model.
  For this model, we will use two model point sets: one for main policy data and the second for coverages.</p>

<span class="source">mult_cov/input.py</span>
<div class="code">
<pre><code>import pandas as pd
from cashflower import ModelPointSet

main = ModelPointSet(data=pd.read_csv("./data/policy.csv"))
coverage = ModelPointSet(data=pd.read_csv("./data/coverage.csv"))</code></pre>
</div>

<p>For each model point instance, we provide data in form of a data frame. Let's take a look.</p>

<div class="code">
<pre><code>print(main.data)
ID  AGE   SEX  PREMIUM
 1   32  MALE      140
</code></pre>
</div>

<p>We will calculate a model for a 32-years-old male who pays a premium of €140.</p>

<div class="code">
<pre><code>print(coverage.data)
ID  SUM_ASSURED     TYPE
 1       100000    DEATH
 1        30000  ILLNESS
</code></pre>
</div>

<p>The policyholder's designated person will receive from the insurance company €100 000 in case of death and €30 000 in case of illness.</p>

<p>We will need 3 assumption tables for this model: mortality rates, morbidity rates and interest rates.</p>

<span class="source">mult_cov/input.py</span>
<div class="code">
<pre><code>import pandas as pd

assumption = dict()
assumption["mortality"] = pd.read_csv("./input/mortality.csv", index_col="AGE")
assumption["morbidity"] = pd.read_csv("./input/morbidity.csv", index_col="AGE")
assumption["interest_rates"] = pd.read_csv("./input/interest_rates.csv", index_col="T")
</code></pre>
</div>

<p>Let's take a look at them.</p>

<div class="code">
<pre><code>print(assumption["mortality"])

        MALE   FEMALE
AGE
0    0.00389  0.00315
1    0.00028  0.00019
2    0.00019  0.00014
3    0.00015  0.00011
4    0.00012  0.00009
..       ...      ...
96   0.28581  0.25969
97   0.30122  0.27829
98   0.31662  0.29696
99   0.33192  0.31554
100  0.34704  0.33387
</code></pre>
</div>

<p>Mortality table has two keys: age and sex. The values are probabilities of death.</p>

<div class="code">
<pre><code>print(assumption["morbidity"])

         MALE    FEMALE
AGE
0    0.002341  0.004178
1    0.000527  0.000252
2    0.000223  0.000134
3    0.000056  0.000009
4    0.000002  0.000074
..        ...       ...
96   0.364924  0.134261
97   0.275834  0.418382
98   0.618544  0.231383
99   0.608570  0.539250
100  0.355988  0.195639
</code></pre>
</div>

<p>In our case, the structure of the morbidity assumption is the same as for mortality. The values are probabilities of becoming ill.</p>

<p>Interest rates will allow us to value cash flows in time.</p>

<div class="code">
<pre><code>print(assumption["interest_rates"])

       VALUE
T
1    0.00736
2    0.01266
3    0.01449
4    0.01610
5    0.01687
..       ...
146  0.03191
147  0.03192
148  0.03194
149  0.03196
150  0.03198
</code></pre>
</div>

<p>We have all the input data that we need. Let's start modelling!</p>

<h3 id="example_model">Model</h3>

<p>Let's start with modelling age, mortality rate, survival rate and expected premium.</p>

<span class="source">mult_cov/model.py</span>
<div class="code">
<pre><code>age = ModelVariable(model_point_set=main)
mortality_rate = ModelVariable(model_point_set=main)
survival_rate = ModelVariable(model_point_set=main)
expected_premium = ModelVariable(model_point_set=main)

@assign(age)
def _age(t):
    if t == 0:
        return int(main.get("AGE"))
    elif t % 12 == 0:
        return age(t-1) + 1
    else:
        return age(t-1)


@assign(mortality_rate)
def _mortality_rate(t):
    sex = main.get("SEX")
    if age(t) == age(t-1):
        return mortality_rate(t-1)
    elif age(t) <= 100:
        yearly_rate = float(assumption["mortality"].loc[age(t)][sex])
        monthly_rate = (1 - (1 - yearly_rate)**(1/12))
        return monthly_rate
    else:
        return 1


@assign(survival_rate)
def _survival_rate(t):
    if t == 0:
        return 1 - mortality_rate(t)
    else:
        return survival_rate(t-1) * (1 - mortality_rate(t))


@assign(expected_premium)
def _expected_premium(t):
    premium = float(main.get("PREMIUM"))
    return premium * survival_rate(t-1)
</code></pre>
</div>

<p>We calculate morbidity rates in an analogous way to mortality rates.</p>

<span class="source">mult_cov/model.py</span>
<div class="code">
<pre><code>morbidity_rate = ModelVariable(model_point_set=main)

@assign(morbidity_rate)
def _morbidity_rate(t):
    sex = main.get("SEX")
    if age(t) == age(t-1):
        return morbidity_rate(t-1)
    elif age(t) <= 100:
        yearly_rate = float(assumption["morbidity"].loc[age(t)][sex])
        monthly_rate = (1 - (1 - yearly_rate)**(1/12))
        return monthly_rate
    else:
        return 1
</code></pre>
</div>

<p>Now we will calculate the expected benefit.</p>

<p>We have two model point sets in our model. We need to indicate with which model point set it is linked.
  The formula will be evaluated for each record of the model point in the given model point set.</p>

<span class="source">mult_cov/model.py</span>
<div class="code">
<pre><code>expected_coverage_benefit = ModelVariable(model_point_set=coverage)

@assign(expected_coverage_benefit)
def _expected_coverage_benefit(t):
    sum_assured = float(coverage.get("SUM_ASSURED"))
    _type = coverage.get("TYPE")

    if _type == "DEATH":
        return survival_rate(t - 1) * mortality_rate(t) * sum_assured
    elif _type == "ILLNESS":
        return survival_rate(t - 1) * morbidity_rate(t) * sum_assured
    else:
        raise ValueError(f"Unknown coverage type {_type}.")
</code></pre>
</div>

<p>The calculation will be repeated for each record in the coverage model point. We read sum assured value and coverage type.
  We have named the variable <span class="inline-code">_type</span> to avoid a clash with Python's built-in <span class="inline-code">type</span> function.
  Depending on the coverage type, we either use mortality rates or morbidity rates to calculate the expected benefit from the coverage.</p>

<p>Knowing the expected benefit for each of the coverages, we can calculate the overall expected benefit.</p>

<span class="source">mult_cov/model.py</span>
<div class="code">
<pre><code>expected_benefit = ModelVariable(model_point_set=main)

@assign(expected_benefit)
def _expected_benefit(t):
    result = 0
    for r in range(coverage.model_point_size):
        result += expected_coverage_benefit(t, r)
    return result
</code></pre>
</div>

<p>To calculate the overall expected benefit, we create a loop. We iterate over each record in the coverage model point and sum up the values.</p>

<p>We can now calculate the present value of expected cash flows and the best estimate of liabilities.</p>

<span class="source">mult_cov/model.py</span>
<div class="code">
<pre><code>projection_year = ModelVariable(model_point_set=main)
yearly_spot_rate = ModelVariable(model_point_set=main)
yearly_forward_rate = ModelVariable(model_point_set=main)
forward_rate = ModelVariable(model_point_set=main)
discount_rate = ModelVariable(model_point_set=main)
pv_expected_premium = ModelVariable(model_point_set=main)
pv_expected_benefit = ModelVariable(model_point_set=main)
best_estimate_liabilities = ModelVariable(model_point_set=main)

@assign(projection_year)
def _projection_year(t):
    if t == 0:
        return 0
    elif t % 12 == 1:
        return projection_year(t - 1) + 1
    else:
        return projection_year(t - 1)


@assign(yearly_spot_rate)
def _yearly_spot_rate(t):
    if t == 0:
        return 0
    else:
        return assumption["interest_rates"].loc[projection_year(t)]["VALUE"]


@assign(yearly_forward_rate)
def _yearly_forward_rate(t):
    if t == 0:
        return 0
    elif t == 1:
        return yearly_spot_rate(t)
    elif t % 12 != 1:
        return yearly_forward_rate(t-1)
    else:
        return ((1+yearly_spot_rate(t))**projection_year(t))/((1+yearly_spot_rate(t-1))**projection_year(t-1)) - 1


@assign(forward_rate)
def _forward_rate(t):
    return (1+yearly_forward_rate(t))**(1/12)-1


@assign(discount_rate)
def _discount_rate(t):
    return 1/(1+forward_rate(t))


@assign(pv_expected_premium)
def _pv_expected_premium(t):
    return expected_premium(t) + pv_expected_premium(t+1) * discount_rate(t+1)


@assign(pv_expected_benefit)
def _pv_expected_benefit(t):
    return expected_benefit(t) + pv_expected_benefit(t+1) * discount_rate(t+1)


@assign(best_estimate_liabilities)
def _best_estimate_liabilities(t):
    return pv_expected_benefit(t) - pv_expected_premium(t)
</code></pre>
</div>

<h3 id="example_results">Results</h3>
<p>To run the model, source the <span class="inline-code">run.py</span> script.</p>

<p>We have produced two output files: one for the policy and one for the coverage. Let's take a look at the subset of columns.</p>


<span class="source">output/&lt;timestamp&gt;_main.csv</span>
<div class="code">
<pre><code>t  expected_benefit  pv_expected_benefit  best_estimate_liabilities
0              0.00             47059.22                    3279.51
1             19.35             47059.22                    3279.51
2             19.35             47068.62                    3402.22
3             19.34             47078.03                    3524.99
4             19.34             47087.45                    3647.82
5             19.34             47096.88                    3770.71
6             19.34             47106.32                    3893.66
7             19.33             47115.77                    4016.66
8             19.33             47125.22                    4139.73
9             19.33             47134.69                    4262.86
10            19.33             47144.16                    4386.05
11            19.32             47153.64                    4509.29
12            15.04             47163.12                    4632.60
</code></pre>
</div>

<br>

<span class="source">output/&lt;timestamp&gt;_coverage.csv</span>
<div class="code">
<pre><code> t  r  expected_coverage_benefit
 0  1                       0.00
 1  1                      12.92
 2  1                      12.92
 3  1                      12.92
 4  1                      12.92
 5  1                      12.92
 6  1                      12.92
 7  1                      12.91
 8  1                      12.91
 9  1                      12.91
10  1                      12.91
11  1                      12.91
12  1                      13.91
 0  2                       0.00
 1  2                       6.43
 2  2                       6.42
 3  2                       6.42
 4  2                       6.42
 5  2                       6.42
 6  2                       6.42
 7  2                       6.42
 8  2                       6.42
 9  2                       6.42
10  2                       6.42
11  2                       6.42
12  2                       1.13
</code></pre>
</div>

<p>Notes:</p>
<ul>
  <li>model produces two outputs,</li>
  <li>expected benefit is linked to the separate model point and has two records (each record has a consecutive number in the <span class="inline-code">r</span> column),</li>
  <li>sum of <span class="inline-code">expected_coverage_benefit</span> in the coverage output amounts to <span class="inline-code">expected_benefit</span> in the main output.</li>
</ul>

</section>
